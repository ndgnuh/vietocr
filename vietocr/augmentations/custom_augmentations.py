import random
import traceback
from dataclasses import field, make_dataclass
from functools import wraps
from inspect import getfullargspec
from typing import Callable, Tuple

import albumentations as A
import cv2
import numpy as np


def rand(inputs):
    """Input selection

    If inputs is a tuple, the function randomize based on the tuple item types.
    - Integer -> `random.rand_int`
    - Float -> `rand.uniform`
    - Bool -> `rand.choice`
    If the inputs is a list, pick one of the items.
    Otherwise, returns the input.

    Args:
        inputs (Tuple[int, int] | Tuple[float, float] | List[T] | S):
            The input for selection
    """
    if isinstance(inputs, tuple):
        a, b = inputs
        if isinstance(a, int):
            return random.randint(a, b)
        if isinstance(a, bool):
            return random.uniform(0, 1) <= 0.5
        else:
            return random.uniform(a, b)
    elif isinstance(inputs, list):
        return random.choice(inputs)
    else:
        return inputs


def safe_run(fn, img: np.ndarray, **options):
    """Try to run something, but in case of errors,
    log to file and return original input image.

    Args:
        fn (Callable): The transform function.
        img (np.ndarray):
            The input image, in case of failure, the image will be returned.

    Keywords:
        **options (Dict): Options for the `fn` transform.
    """
    try:
        return fn(img, **options)
    except Exception:
        trace = traceback.format_exc()
        print(trace)
        with open("error.txt", "a+", encoding="utf-8") as f:
            f.write(trace)
        return img


def make_transform(name: str, fn: Callable, Base=A.ImageOnlyTransform):
    """A mild black magic function, make a transformation from
    a functional transform.

    Args:
        name (str): Name of the transformation class.
        fn (Callable):
            The functional transformation, need to be annotated with default arguments.
        Base (type):
            The base class for the transformation.
            The default is `A.ImageOnlyTransform`.
    """
    # +--------------------------+
    # | Get fields from function |
    # +--------------------------+
    ann = getfullargspec(fn)
    num_defaults = len(ann.defaults)
    option_names = ann.args[-num_defaults:]
    fields = []
    for i in range(num_defaults):
        arg = option_names[i]
        type = ann.annotations[arg]
        default = field(default=ann.defaults[i])
        ds_field = (arg, type, default)
        fields.append(ds_field)

    # +---------------------------------------+
    # | Make a dataclass to hold and validate |
    # | the transformation function input     |
    # +---------------------------------------+
    ParamClass = make_dataclass(f"{name}Params", fields)

    # +-----------------------------------+
    # | The transformation function class |
    # +-----------------------------------+
    class TransformClass(Base):
        def __init__(self, p=0.5, always_apply=False, **kwargs):
            super().__init__(p=p, always_apply=always_apply)
            self.params = vars(ParamClass(**kwargs))
            for k, v in self.params.items():
                setattr(self, k, v)
            self.__doc__ = self.__class__.__doc__

        def apply(self, img, **kwargs):
            return safe_run(fn, img, **self.params)

        def get_transform_init_args_names(self):
            return option_names

    # +---------------------------------------------------------+
    # | Change global stuff, such as name, qualifier, docstring |
    # +---------------------------------------------------------+
    TransformClass.__name__ = name
    TransformClass.__qualname__ = name
    wraps(fn)(TransformClass.apply)
    return TransformClass


class FBMNoise(A.ImageOnlyTransform):
    """Add noise generated by fractional brownian motion.

    Args:
        mix (Tuple[float, float]): Image alpha when mixing with noise, default to (0.6, 0.8).
        p (float): Apply probability, default value is 0.5.
        always_apply (bool): Always apply.
    """

    def __init__(
        self,
        p: float = 0.5,
        always_apply: bool = True,
        mix: Tuple[float, float] = (0.6, 0.8),
    ):
        super().__init__(p=p, always_apply=always_apply)
        self.mix = mix

    def get_transform_init_args_names(self):
        return ["mix"]

    def apply(self, img: np.ndarray, **kwargs):
        h, w, c = img.shape

        # +--------------------+
        # | Generate fBM noise |
        # +--------------------+
        positions = np.indices([h, w]) * 3 / max(h, w)
        positions = positions.reshape(2, h * w).transpose(1, 0)
        noise = self.gen_fbm(positions).reshape(h, w, 1)
        noise = (np.clip(noise, 0, 1) * 255).astype(np.uint8)

        # +-------+
        # | Blend |
        # +-------+
        mix = np.random.uniform(*self.mix)
        noise = np.broadcast_to(noise, (h, w, c))
        w1 = (np.ones([h, w]) * mix).astype(np.float32)
        w2 = 1 - w1
        img = cv2.blendLinear(img, noise, w1, w2)
        return img

    def random(self, positions, seed0, seed1):
        # generate 1d noise
        noise = np.sum(seed0 * positions, axis=1)
        noise, _ = np.modf(np.sin(noise + seed1))
        return noise

    def gen_fbm(self, positions):
        seed0 = np.random.uniform(0, 100, (1, 2))
        seed1 = np.random.uniform(0, 10000)
        value = 0
        amp = np.random.uniform(0.3, 0.7)
        frequency = np.random.rand()
        octave = np.random.randint(5, 10)
        for i in range(octave):
            value = value + amp * self.gen_2d_noise(positions, seed0, seed1)
            positions = positions * 2
            amp = amp * 0.5
        return value

    def gen_2d_noise(self, positions, seed0, seed1):
        i = np.floor(positions)
        f = positions - i

        a = self.random(i, seed0, seed1)
        b = self.random(i + np.array([[1, 0]]), seed0, seed1)
        c = self.random(i + np.array([[0, 1]]), seed0, seed1)
        d = self.random(i + np.array([[1, 1]]), seed0, seed1)

        u = f * f * (3 - 2 * f)
        return (
            (a * (1 - u[..., 0]) + b * (u[..., 0]))
            + (c - a) * u[..., 1] * (1 - u[..., 0])
            + (d - b) * u[..., 0] * u[..., 1]
        )


def scale_degrade(img, scale: Tuple[float, float] = (1.2, 2.2)):
    """Degrade image by scale down width and height

    Args:
        min_scale (float): Min width/height scale
        max_scale (float): Max width/height scale
    """
    scale = rand(scale)
    h, w = img.shape[:2]
    img = cv2.resize(img, (int(w / scale), int(h / scale)))
    img = cv2.resize(img, (w, h))
    return img


def random_color_patch_overlay(
    image,
    num_h_splits: Tuple[int, int] = (1, 5),
    num_v_splits: Tuple[int, int] = (3, 20),
    color_opacity: Tuple[float, float] = (0.2, 0.5),
):
    """Overlay image with patches of random colors

    Args:
        image (ndarray): Input image.
        num_h_splits (Tuple[int, int] | int): Number of row patches.
        num_v_splits (Tuple[int, int] | int): Number of column patches.
        color_opacity (Tuple[float, float] | float): The opacity of color patches.
    """
    h, w, c = image.shape
    dtype = image.dtype
    image = np.copy(image)

    # +-----------------+
    # | Helper function |
    # +-----------------+
    def color_overlay(image, color, rate):
        image = image * rate + color * (1 - rate)
        image = image.astype(dtype)
        return image

    # +----------------+
    # | Divide patches |
    # +----------------+
    num_h_splits = random.randrange(*num_h_splits)
    num_v_splits = random.randrange(*num_v_splits)
    s_height = h // num_h_splits
    s_width = w // num_v_splits
    for i in range(num_h_splits):
        for j in range(num_v_splits):
            # +--------------------------------+
            # | Compute region for color patch |
            # +--------------------------------+
            h_slice = slice(i * s_height, (i + 1) * s_height)
            v_slice = slice(j * s_width, (j + 1) * s_width)
            region = [h_slice, v_slice]

            # +---------+
            # | Overlay |
            # +---------+
            color = np.random.randint(0, 256, (1, 1, c), dtype=dtype)
            src = image[*region, :]
            color = np.broadcast_to(color, src.shape)
            weights2 = np.random.uniform(*color_opacity, src.shape[:2])
            weights2 = weights2.astype(np.float32)
            weights1 = 1 - weights2
            image[*region, :] = cv2.blendLinear(src, color, weights1, weights2)
    return image


ColorPatchOverlay = make_transform("ColorPatchOverlay", random_color_patch_overlay)
ScaleDegrade = make_transform("ScaleDegrade", scale_degrade)
