import random
from typing import Tuple

import albumentations as A
import cv2
import numpy as np


class FBMNoise(A.ImageOnlyTransform):
    """Add noise generated by fractional brownian motion.

    Args:
        mix (Tuple[float, float]): Image alpha when mixing with noise, default to (0.6, 0.8).
        p (float): Apply probability, default value is 0.5.
        always_apply (bool): Always apply.
    """

    def __init__(
        self,
        p: float = 0.5,
        always_apply: bool = True,
        mix: Tuple[float, float] = (0.6, 0.8),
    ):
        super().__init__(p=p, always_apply=always_apply)
        self.mix = mix

    def get_transform_init_args_names(self):
        return ["mix"]

    def apply(self, img: np.ndarray, **kwargs):
        h, w, c = img.shape

        # +--------------------+
        # | Generate fBM noise |
        # +--------------------+
        positions = np.indices([h, w]) * 3 / max(h, w)
        positions = positions.reshape(2, h * w).transpose(1, 0)
        noise = self.gen_fbm(positions).reshape(h, w, 1)
        noise = (np.clip(noise, 0, 1) * 255).astype(np.uint8)

        # +-------+
        # | Blend |
        # +-------+
        mix = np.random.uniform(*self.mix)
        noise = np.broadcast_to(noise, (h, w, c))
        w1 = (np.ones([h, w]) * mix).astype(np.float32)
        w2 = 1 - w1
        img = cv2.blendLinear(img, noise, w1, w2)
        return img

    def random(self, positions, seed0, seed1):
        # generate 1d noise
        noise = np.sum(seed0 * positions, axis=1)
        noise, _ = np.modf(np.sin(noise + seed1))
        return noise

    def gen_fbm(self, positions):
        seed0 = np.random.uniform(0, 100, (1, 2))
        seed1 = np.random.uniform(0, 10000)
        value = 0
        amp = np.random.uniform(0.3, 0.7)
        frequency = np.random.rand()
        octave = np.random.randint(5, 10)
        for i in range(octave):
            value = value + amp * self.gen_2d_noise(positions, seed0, seed1)
            positions = positions * 2
            amp = amp * 0.5
        return value

    def gen_2d_noise(self, positions, seed0, seed1):
        i = np.floor(positions)
        f = positions - i

        a = self.random(i, seed0, seed1)
        b = self.random(i + np.array([[1, 0]]), seed0, seed1)
        c = self.random(i + np.array([[0, 1]]), seed0, seed1)
        d = self.random(i + np.array([[1, 1]]), seed0, seed1)

        u = f * f * (3 - 2 * f)
        return (
            (a * (1 - u[..., 0]) + b * (u[..., 0]))
            + (c - a) * u[..., 1] * (1 - u[..., 0])
            + (d - b) * u[..., 0] * u[..., 1]
        )


class ScaleDegrade(A.ImageOnlyTransform):
    """Degrade image by scale down width and height

    Args:
        min_scale (float): Min width/height scale
        max_scale (float): Max width/height scale
        p (float): Augment probs, default `0.5`
        always_apply (bool): Always apply, default `False`
    """

    def __init__(
        self,
        min_scale: float = 1.2,
        max_scale: float = 2.2,
        p: float = 0.5,
        always_apply: bool = False,
    ):
        super().__init__(p=p, always_apply=always_apply)
        self.max_scale = max_scale
        self.min_scale = min_scale
        self.p = p

    def get_transform_init_args_names(self):
        return ["min_scale", "max_scale"]

    def apply(self, img: np.ndarray, **params):
        scale = random.uniform(self.min_scale, self.max_scale)
        h, w = img.shape[:2]
        img = cv2.resize(img, (int(w / scale), int(h / scale)))
        img = cv2.resize(img, (w, h))
        return img


def random_patchwise_color_overlay(
    image,
    num_h_splits: Tuple[int, int] = (1, 5),
    num_v_splits: Tuple[int, int] = (3, 20),
    color_opacity: Tuple[float, float] = (0.7, 0.9),
):
    """See `ColorPatchOverlay`"""
    h, w, c = image.shape
    dtype = image.dtype
    image = np.copy(image)

    # +-----------------+
    # | Helper function |
    # +-----------------+
    def color_overlay(image, color, rate):
        image = image * rate + color * (1 - rate)
        image = image.astype(dtype)
        return image

    # +----------------+
    # | Divide patches |
    # +----------------+
    num_h_splits = random.randrange(*num_h_splits)
    num_v_splits = random.randrange(*num_v_splits)
    s_height = h // num_h_splits
    s_width = w // num_v_splits
    for i in range(num_h_splits):
        for j in range(num_v_splits):
            # +--------------------------------+
            # | Compute region for color patch |
            # +--------------------------------+
            h_slice = slice(i * s_height, (i + 1) * s_height)
            v_slice = slice(j * s_width, (j + 1) * s_width)
            region = [h_slice, v_slice]

            # +---------+
            # | Overlay |
            # +---------+
            color = np.random.randint(0, 256, (1, 1, c), dtype=dtype)
            src = image[*region, :]
            color = np.broadcast_to(color, src.shape)
            weights2 = np.random.uniform(*color_opacity, src.shape[:2]).astype(
                np.float32
            )
            weights1 = 1 - weights2
            image[*region, :] = cv2.blendLinear(src, color, weights1, weights2)
    return image


class ColorPatchOverlay(A.ImageOnlyTransform):
    """Overlay image patches with random color patches

    Args:
        image (np.ndarray): Image
        num_h_splits (Tuple[int, int]): Min and maximum number of horizontal splits. Default: [1, 5].
        num_v_splits (Tuple[int, int]): Min and maximum number of vertical splits. Default: [3, 30].
        color_opacity (Tuple[float, float]): Blend ratio for color patch. Default: (0.1, 0.3).
    """

    def __init__(
        self,
        num_h_splits: Tuple[int, int] = (1, 5),
        num_v_splits: Tuple[int, int] = (3, 30),
        color_opacity: Tuple[float, float] = (0.1, 0.3),
        p: float = 0.5,
        always_apply: bool = False,
    ):
        super().__init__(p=p, always_apply=always_apply)
        self.num_h_splits = num_h_splits
        self.num_v_splits = num_v_splits
        self.color_opacity = color_opacity

    def get_transform_init_args_names(self):
        return ["num_h_splits", "num_v_splits", "color_opacity"]

    def apply(self, img: np.ndarray, **params):
        return random_patchwise_color_overlay(
            img,
            self.num_h_splits,
            self.num_v_splits,
            self.color_opacity,
        )


def shift_blur(image, shift: int, vertical: bool):
    """Abberation without color"""
    image = np.copy(image)
    if vertical:
        image[shift:, ...] = image[shift:, ...] * 0.5 + image[:-shift, ...] * 0.5
    else:
        image[:, shift:, ...] = (
            image[:, shift:, ...] * 0.5 + image[:, :-shift, ...] * 0.5
        )
    return image


class RandomShiftBlur(A.ImageOnlyTransform):
    """See `shift_blur`

    Args:
        shift_range (Tuple[int, int]): Min and max shift pixel.
    """

    def __init__(
        self,
        shift_range: Tuple[int, int] = (1, 2),
        p: float = 0.5,
        always_apply: bool = True,
    ):
        super().__init__(p=p, always_apply=always_apply)
        self.shift_range = shift_range

    def apply(self, img, **kw):
        verticals = random.choices([True, False], k=2)
        for vertical in verticals:
            shift = random.randint(*self.shift_range)
            img = shift_blur(img, shift, vertical)
        return img

    def get_transform_init_args_names(self):
        return ["shift_range"]
